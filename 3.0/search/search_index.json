{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"","title":"Home"},{"location":"about/","text":"About Us \u00b6 We are mobile developers, based in Paris, working with hybrid and cross platform technologies. Our goal is to help the client's business succeed, by solving their problems together using agile and lean, and developing the best product to satisfy the client's user needs. Learn more about us in our french website .","title":"About Us"},{"location":"about/#about-us","text":"We are mobile developers, based in Paris, working with hybrid and cross platform technologies. Our goal is to help the client's business succeed, by solving their problems together using agile and lean, and developing the best product to satisfy the client's user needs. Learn more about us in our french website .","title":"About Us"},{"location":"api/","text":"API \u00b6 The API has its own website. Please head to /api/ .","title":"API"},{"location":"api/#api","text":"The API has its own website. Please head to /api/ .","title":"API"},{"location":"guides/context/","text":"Context \u00b6","title":"Context"},{"location":"guides/context/#context","text":"","title":"Context"},{"location":"guides/events/","text":"Events \u00b6","title":"Events"},{"location":"guides/events/#events","text":"","title":"Events"},{"location":"guides/getting-started/","text":"Quick Start \u00b6 State ids and event declaration \u00b6 Extend the SimpleStateId type. object TrafficLightRootStateId : SimpleStateId sealed class TrafficLightStateId : SimpleStateId { object RED : TrafficLightStateId () object YELLOW : TrafficLightStateId () object GREEN : TrafficLightStateId () } sealed class TrafficLightEvent { object TIMER : TrafficLightEvent () object SHORT_TIMER : TrafficLightEvent () } Transition between states \u00b6 val machine = createMachine ( id = TrafficLightRootStateId , initial = RED ) { state ( RED ) { transition ( on = TIMER , target = GREEN ) } state ( GREEN ) { transition ( on = TIMER , target = YELLOW ) } state ( YELLOW ) { transition ( on = TIMER , target = RED ) } } machine . send ( TIMER ) assertEquals ( GREEN , machine . currentStateId ) WIP \u00b6 Transition between nested states \u00b6 val machine = createMachine { initial ( RED ) state ( RED ) { initial ( WALK ) state ( WALK ) { transition ( on = SHORT_TIMER , target = WAIT ) } state ( WAIT ) } } machine . send ( SHORT_TIMER ) assertEquals ( listOf ( RED , WAIT ), machine . activeStateIds ()) Transition between nested state with the internal strategy \u00b6 With the internal strategy, all events are passed to children before they are passed to the compound state. val machine = createMachine ( strategy = KSStrategyType . Internal ) { initial ( RED ) state ( RED ) { transition ( on = TIMER , target = YELLOW ) initial ( WALK ) state ( WALK ) { transition ( on = TIMER , target = WAIT ) } state ( WAIT ) } state ( YELLOW ) } machine . send ( TIMER ) assertEquals ( listOf ( RED , WAIT ), machine . activeStateIds ()) Parallel state machine \u00b6 val machine = createMachine ( type = Type . Parallel ) { state ( TRAFFIC_LIGHT ) { initial ( RED ) state ( RED ) { transition ( on = TIMER , target = GREEN ) } state ( GREEN ) { transition ( on = TIMER , target = RED ) } } state ( PEDESTRIAN_LIGHT ) { initial ( WAIT ) state ( WAIT ) { transition ( on = TIMER , target = WALK ) } state ( WALK ) { transition ( on = TIMER , target = WAIT ) } } } machine . send ( TIMER ) assertEquals ( listOf ( TRAFFIC_LIGHT , GREEN , PEDESTRIAN_LIGHT , WALK ), machine . activeStateIds () ) Listen for transitions \u00b6 val machine = createMachine { initial ( RED ) state ( RED ) state ( YELLOW ) state ( GREEN ) } val listener = MachineTransitionListener { previousActiveStateIds , nextActiveStateIds -> print ( \"I'm listening.\" ) } machine . subscribe ( listener ) machine . unsubscribe ( listener ) // OR machine . onTransition { previousActiveStateIds , nextActiveStateIds -> print ( \"I'm listening.\" ) }","title":"Quick Start"},{"location":"guides/getting-started/#quick-start","text":"","title":"Quick Start"},{"location":"guides/getting-started/#state-ids-and-event-declaration","text":"Extend the SimpleStateId type. object TrafficLightRootStateId : SimpleStateId sealed class TrafficLightStateId : SimpleStateId { object RED : TrafficLightStateId () object YELLOW : TrafficLightStateId () object GREEN : TrafficLightStateId () } sealed class TrafficLightEvent { object TIMER : TrafficLightEvent () object SHORT_TIMER : TrafficLightEvent () }","title":"State ids and event declaration"},{"location":"guides/getting-started/#transition-between-states","text":"val machine = createMachine ( id = TrafficLightRootStateId , initial = RED ) { state ( RED ) { transition ( on = TIMER , target = GREEN ) } state ( GREEN ) { transition ( on = TIMER , target = YELLOW ) } state ( YELLOW ) { transition ( on = TIMER , target = RED ) } } machine . send ( TIMER ) assertEquals ( GREEN , machine . currentStateId )","title":"Transition between states"},{"location":"guides/getting-started/#wip","text":"","title":"WIP"},{"location":"guides/getting-started/#transition-between-nested-states","text":"val machine = createMachine { initial ( RED ) state ( RED ) { initial ( WALK ) state ( WALK ) { transition ( on = SHORT_TIMER , target = WAIT ) } state ( WAIT ) } } machine . send ( SHORT_TIMER ) assertEquals ( listOf ( RED , WAIT ), machine . activeStateIds ())","title":"Transition between nested states"},{"location":"guides/getting-started/#transition-between-nested-state-with-the-internal-strategy","text":"With the internal strategy, all events are passed to children before they are passed to the compound state. val machine = createMachine ( strategy = KSStrategyType . Internal ) { initial ( RED ) state ( RED ) { transition ( on = TIMER , target = YELLOW ) initial ( WALK ) state ( WALK ) { transition ( on = TIMER , target = WAIT ) } state ( WAIT ) } state ( YELLOW ) } machine . send ( TIMER ) assertEquals ( listOf ( RED , WAIT ), machine . activeStateIds ())","title":"Transition between nested state with the internal strategy"},{"location":"guides/getting-started/#parallel-state-machine","text":"val machine = createMachine ( type = Type . Parallel ) { state ( TRAFFIC_LIGHT ) { initial ( RED ) state ( RED ) { transition ( on = TIMER , target = GREEN ) } state ( GREEN ) { transition ( on = TIMER , target = RED ) } } state ( PEDESTRIAN_LIGHT ) { initial ( WAIT ) state ( WAIT ) { transition ( on = TIMER , target = WALK ) } state ( WALK ) { transition ( on = TIMER , target = WAIT ) } } } machine . send ( TIMER ) assertEquals ( listOf ( TRAFFIC_LIGHT , GREEN , PEDESTRIAN_LIGHT , WALK ), machine . activeStateIds () )","title":"Parallel state machine"},{"location":"guides/getting-started/#listen-for-transitions","text":"val machine = createMachine { initial ( RED ) state ( RED ) state ( YELLOW ) state ( GREEN ) } val listener = MachineTransitionListener { previousActiveStateIds , nextActiveStateIds -> print ( \"I'm listening.\" ) } machine . subscribe ( listener ) machine . unsubscribe ( listener ) // OR machine . onTransition { previousActiveStateIds , nextActiveStateIds -> print ( \"I'm listening.\" ) }","title":"Listen for transitions"},{"location":"guides/hierarchical-state/","text":"Hierarchical State \u00b6","title":"Hierarchical State"},{"location":"guides/hierarchical-state/#hierarchical-state","text":"","title":"Hierarchical State"},{"location":"guides/parallel-states/","text":"Parallel States \u00b6","title":"Parallel States"},{"location":"guides/parallel-states/#parallel-states","text":"","title":"Parallel States"},{"location":"guides/states/","text":"States \u00b6","title":"States"},{"location":"guides/states/#states","text":"","title":"States"},{"location":"guides/transitions/","text":"Transitions \u00b6","title":"Transitions"},{"location":"guides/transitions/#transitions","text":"","title":"Transitions"}]}